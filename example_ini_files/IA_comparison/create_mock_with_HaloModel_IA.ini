; This ini file is to use the test sampler to produce
; GI and II power spectra using the Halo Model 

[DEFAULT]
nz_def = 10 
nk_def = 300
zmin_def =  0.2
zmax_def = 1.2
nmass_def = 200
logmassmin_def = 9.0
logmassmax_def = 16.0
RUN_NAME = HM_IA
MY_PATH = /Users/cheymans/CosmoSIS/
CSL_PATH = %(MY_PATH)s/cosmosis-standard-library
pipeline_path = %(MY_PATH)s/halomodel_for_cosmosis

[pipeline]
timing=T
debug=T
modules =   consistency camb extrapolate hmf_and_halo_bias nfw_halo
            hod_red red_alignment radial_satellite_alignment_red 
            hod_blue blue_alignment radial_satellite_alignment_blue #bnl
            pk_red pk_blue add_red_and_blue_power

values = %(pipeline_path)s/example_ini_files/values_test.ini


; Since CosmoSIS v3, the consistency interface allows for sampling over S8
; Here we set up the non-linear power spectrum
[consistency]
file = %(CSL_PATH)s/utility/consistency/consistency_interface.py

[camb]
file = %(CSL_PATH)s/boltzmann/camb/camb_interface.py
mode = all
halofit_version = mead2020_feedback  
neutrino_hierarchy = normal
lmax=2500
kmax=100.0
zmid = 2.0
nz_mid = 100
zmax = 6.0
nz = 150
feedback=0

[extrapolate]
file = %(CSL_PATH)s/boltzmann/extrapolate/extrapolate_power.py
kmax = 1e8
nmax = 0 ; 2580

; Now we have a power spectrum, it's time to define the
; dark matter halo mass function and halo bias
[hmf_and_halo_bias]
file = %(pipeline_path)s/hmf_and_hbf_tinker.py
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin= %(zmin_def)s
zmax= %(zmax_def)s
nz= %(nz_def)s
; Options for hmf_model are same as given by the hmf package
; Options for bias_model are the same as give by halomod package
; mdef_model options are the same as used in hmf and halomod packages
; cm_models are the same as used by colossus package
hmf_model =  ST ;Tinker10
bias_model =  ST99 ;Tinker10
mdef_model =  SOVirial ;SOMean
overdensity = 200
delta_c = 1.686
cm_model =  bullock01 ;duffy08
; The parameter 'use_mead2020_corrections' specifies which corrections to the Pmm to use:
; options are: 'mead2020', 'mead2020_feedback', 'fit_feedback', for which the first two are the same as used by CAMB,
; and 'fit_feedback' allows one to fit for the feedback using f* derived from HOD and concentration parameters.
; USED by nfw module and pk modules as well!
; use_mead2020_corrections = mead2020_feedback

; Next we're going to add galaxies using an HOD
[hod_red]
file = %(pipeline_path)s/hod_interface.py
; if observables_z = True, then the luminosities are read from the luminosities_file [z_mid, lum_min(z), lum_max(z)]
; TODO: describe how to construct such a file!
observables_z = True
observables_file = %(pipeline_path)s/input_files/red_cen_lum_pdf.txt
nobs = 200
; -
; obs_min, obs_max, zmin, zmax and nz are only needed if observables_z = False
; Also specifies the number of stellar mass bins used in the model and will produce hod per bin that is then used in the pk module
; The length of obs_min, obs_max, zmin, zmax need to be the same
; -
; obs_min = 10.0,10.3,10.6
; obs_max = 10.3,10.6,10.9
; zmin = 0.0,0.1,0.2
; zmax = 0.1,0.2,0.3
; nz = %(nz_def)s
abs_mag_sun = 4.68
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
z_median = 0.4
do_hod = True
do_number_density = True
do_galaxy_linear_bias = True
do_observable_function = True
; options are: "obs_z", "obs_zmed" or "obs_onebin" depending if you want to calculate the LF per each 
; redshift or on the median one or per one big bin
observable_mode = "obs_z"
output_suffix = red       ; output suffix to the default block name
params_suffix = red       ; suffix to the default parameter section

[hod_blue]
file = %(pipeline_path)s/hod_interface.py
; if luminosities_z = True, then the luminosities are read from the luminosities_file [z_mid, lum_min(z), lum_max(z)]
observables_z = True
observables_file = %(pipeline_path)s/input_files/blue_cen_lum_pdf.txt
nobs = 200
; -
; obs_min, obs_max, zmin, zmax and nz are only needed if observables_z = False
; -
;obs_min = 4.698941e+08
;obs_max = 1.180321e+11
;zmin = %(zmin_def)s
;zmax = %(zmax_def)s
;nz = %(nz_def)s
abs_mag_sun = 4.68
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
z_median = 0.1
do_hod = True
do_number_density = True
do_galaxy_linear_bias = True
do_observable_function = True
; options are: "obs_z", "obs_zmed" or "obs_onebin" depending if you want to calculate the LF per each redshift or 
; on the median one or per one big bin
observable_mode = "obs_zmed"
output_suffix = blue
params_suffix = blue

[extrapolate_obs]
; Interpolates and extrapolates the observable function that is returned by the hod module so it can be 
; used by the twopoint and scale cuts module when calculating the likelihood. It requires the sample input 
; which is the n(z) for the given bin if observable function is desired to be weighted by n(z).
; When one calculates the observable function at "z_med", sample is not required, nor the suffixes.
; obs_min, obs_max should be the min and max values of the input data, n_obs the number of data points. 
; If per bin, they all need to be specified as such.
file = %(pipeline_path)s/extrapolate_obs.py
input_section_name = observable_function_red
output_section_name = smf_red
; suffixes = 1 ; ,2
sample = nz_lens
obs_min = 9.3 ; ,10.4
obs_max = 11.3 ;10.1 ; ,11.3
n_obs = 12 ; 6,6

[nfw_halo]
file = %(pipeline_path)s/nfw_halo.py
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
nk = %(nk_def)s
; profile = NFW ; Future option, not yet implemented


# This takes the luminosity of your sample to calculate
# the luminosity dependent amplitude of the IA single as e.g A(L) = (L/L_0)^beta for the Joachimi2011 option
[red_alignment]
file = %(pipeline_path)s/ia_amplitudes.py
; for centrals, the choices are : 'constant', 'Joachimi2011' (single power law), 'double_powerlaw' or 'halo_mass'
centrals_luminosity_dependence = double_powerlaw
z_loglum_file_centrals = %(pipeline_path)s/input_files/redcen_lum.fits ; a fits file containing the columns 'z' and 'loglum'
; for satellites, the choices are : 'constant', 'satellite_luminosity_dependence' (power law) or 'halo_mass'
satellites_luminosity_dependence = satellite_luminosity_dependence
z_loglum_file_satellites = %(pipeline_path)s/input_files/redsat_lum.fits
zmin= %(zmin_def)s
zmax= %(zmax_def)s
nz = %(nz_def)s
output_suffix = red


[blue_alignment]
file = %(pipeline_path)s/ia_amplitudes.py
centrals_luminosity_dependence = constant
satellites_luminosity_dependence = satellite_luminosity_dependence
z_loglum_file_satellites = %(pipeline_path)s/input_files/bluesat_lum.fits
zmin= %(zmin_def)s
zmax= %(zmax_def)s
nz = %(nz_def)s
output_suffix = blue


[radial_satellite_alignment_red]
file = %(pipeline_path)s/wkm_interp_interface_eps.py
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
kmin = 0.0001
kmax = 1000.
nk = 1000
output_suffix=red

[radial_satellite_alignment_blue]
file = %(pipeline_path)s/wkm_interp_interface_eps.py
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
kmin = 0.1
kmax = 1000.
nk = 1000
output_suffix=blue


[bnl]
; Calculates the non-linear halo bias correction beta_nl using the DarkEmulator
; interpolate_bnl is now set to True always
; update_bnl specifies how often the beta_nl gets recalculated (how many calls to the model in between)
file= %(pipeline_path)s/bnl_interface.py
;log-spaced mass in units of M_sun/h
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
nk = %(nk_def)s
bnl = False
interpolate_bnl = True
update_bnl = 10

[pk_red]
file= %(pipeline_path)s/pk_interface.py
;log-spaced mass in units of M_sun/h
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
nk = %(nk_def)s
pipeline = False
p_mm = True
p_mm_bnl = False
p_gg = True
p_gg_bnl = False
p_gm = True
p_gm_bnl = False
p_gI = True
p_mI = True
p_II = True
p_gI_bnl = False
p_mI_bnl = False
p_II_bnl = False
two_halo_only = False
hod_section_name = hod_red  ; Input hod section
output_suffix = red         ; Output suffix to the default block name
poisson_type = scalar       ; Specifies the type of the Poisson parameter model
                            ; Can be 'scalar', 'power_law', 'scalar_per_bin'

[pk_blue]
file= %(pipeline_path)s/pk_interface.py
;log-spaced mass in units of M_sun/h
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
nk = %(nk_def)s
pipeline = False
p_mm = True
p_mm_bnl = False
p_gg = True
p_gg_bnl = False
p_gm = True
p_gm_bnl = False
p_gI = True
p_mI = True
p_II = True
p_gI_bnl = False
p_mI_bnl = False
p_II_bnl = False
two_halo_only = False
hod_section_name = hod_blue
output_suffix = blue
poisson_type = scalar

[add_red_and_blue_power]
file = %(pipeline_path)s/add_red_and_blue_power_spectra.py
f_red_file = %(pipeline_path)s/input_files/f_red.txt ; two columns: z f_red(z)
; options below are False, extrapolate, add_and_extrapolate
; If option add_and_extrapolate is selected, the f_red_file
; is needed to account for red/blue fraction correctly
do_p_mm = False
do_p_gg = extrapolate
do_p_gm = extrapolate
do_p_gI = False
do_p_mI = False
do_p_II = False
input_suffix_extrap = red
input_suffix_red = red
input_suffix_blue = blue




[runtime]
sampler = test
verbosity = standard
root = ${COSMOSIS_SRC_DIR}

[test]
save_dir=output/%(RUN_NAME)s
fatal_errors = T